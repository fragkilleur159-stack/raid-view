<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üî• Raid Au Coin Du Feu</title>

  <style>

    .items-panel {
      background: rgba(35, 10, 0, 0.95);
      border: 1px solid rgba(255, 160, 80, 0.4);
      box-shadow: 0 0 20px rgba(255, 120, 60, 0.4);
      padding: 16px;
      border-radius: 12px;
      position: fixed;
      right: 20px;
      top: 20%;
      width: 260px;
      z-index: 100;
    }

    .items-list button {
      width: 100%;
      margin-bottom: 6px;
      padding: 6px;
      background: linear-gradient(90deg, #cc5500, #ff9a00);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    .close-items-btn {
      width: 100%;
      margin-top: 10px;
      padding: 6px;
      background: rgba(255, 80, 40, 0.7);
      border-radius: 8px;
      border: none;
      cursor: pointer;
    }

    /* --- TCHAT RAID --- */
    .chat-card {
      background: rgba(35, 10, 0, 0.9);
      padding: 16px;
      border-radius: 14px;
      box-shadow:
        0 0 25px rgba(255, 80, 0, 0.25),
        0 0 80px rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 150, 70, 0.18);
      max-height: 420px;
      display: flex;
      flex-direction: column;
    }

    .chat-title {
      margin: 0 0 6px 0;
      color: #ffddaa;
      font-weight: 700;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
      font-size: 13px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.25);
      padding: 6px 8px;
    }

    .chat-message {
      margin-bottom: 4px;
    }

    .chat-message span.chat-name {
      font-weight: 600;
      color: #ffebcc;
    }

    .chat-message span.chat-spectator-tag {
      font-size: 11px;
      color: #ff9a66;
      margin-right: 4px;
    }

    .chat-message span.chat-text {
      color: #ffe6cc;
    }

    .chat-input-row {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    .chat-input-row input {
      flex: 1;
      background: rgba(10, 2, 0, 0.9);
      border-radius: 8px;
      border: 1px solid rgba(255, 160, 80, 0.7);
      padding: 5px 8px;
      color: #ffe0c2;
      font-size: 13px;
    }

    .chat-input-row button {
      border: none;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(90deg, #cc5500, #ff9a00);
      color: #2a0500;
    }

    .chat-hint {
      margin-top: 4px;
      font-size: 11px;
      color: #ffcc99;
    }

    /* Layout 2 colonnes sur grand √©cran */
  @media (min-width: 950px) {
    .container {
      display: grid;
      grid-template-columns: 2fr 1fr;
      grid-template-rows: auto auto;
      gap: 20px;
    }
    .status-pill {
      grid-column: 1 / 3;
    }
    .card,
    .attack-card,
    .participants-card {
      grid-column: 1 / 2;
    }
    .chat-card {
      grid-column: 2 / 3;
      grid-row: 2 / 4;
    }
  }
    
    .hit-log-row .hit-dmg {
      font-weight: 600;
    }

        /* d√©g√¢ts normaux */
    .hit-log-row.normal .hit-dmg {
      color: #ffb36b;
    }

    /* critique */
    .hit-log-row.crit .hit-dmg {
      color: #ffe066;
      text-shadow: 0 0 6px #ffe066, 0 0 12px rgba(255, 230, 150, 0.6);
    }

    /* sp√©cial / ultime */
    .hit-log-row.ultimate .hit-dmg,
    .hit-log-row.special .hit-dmg {
      color: #ff4444;
      font-weight: 800;
      text-shadow: 0 0 6px #ff2222, 0 0 14px rgba(255, 0, 0, 0.7);
    }

    /* nom du boss en rouge */
    .hit-log-row.boss .hit-name {
      color: #ff8080;
    }
    
    /* Boss qui tremble quand il se fait toucher */
    .boss-image-wrapper.hit {
      animation: bossShake 0.35s ease-out;
    }

    @keyframes bossShake {
      0%   { transform: translateX(0); }
      20%  { transform: translateX(-4px); }
      40%  { transform: translateX(4px); }
      60%  { transform: translateX(-3px); }
      80%  { transform: translateX(3px); }
      100% { transform: translateX(0); }
    }

    /* Texte de d√©g√¢ts qui flotte au-dessus de la barre de vie */
    .damage-popup {
      position: absolute;
      left: 50%;
      top: -4px;
      transform: translateX(-50%);
      font-size: 16px;
      font-weight: 800;
      color: #ffe6dd;
      text-shadow:
        0 0 4px #ff4500,
        0 0 10px rgba(0, 0, 0, 0.9);
      pointer-events: none;
      animation: dmgFloat 0.9s ease-out forwards;
    }

    @keyframes dmgFloat {
      0% {
        opacity: 1;
        transform: translate(-50%, 0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -35px) scale(1.1);
      }
    }

    /* Variantes de couleur pour les types de coups */
    .damage-popup.normal {
      color: #ffd9b3;
    }
    .damage-popup.crit {
      color: #fffbcc;
      text-shadow:
        0 0 6px #ffe066,
        0 0 14px rgba(255, 180, 80, 0.9);
    }
    .damage-popup.special {
      color: #ffe6ff;
      text-shadow:
        0 0 6px #ff66aa,
        0 0 14px rgba(255, 80, 140, 0.9);
    } 

    /* Flash rouge quand le boss attaque (overlay fullscreen) */
    .boss-attack-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at center, rgba(255,0,0,0.55), transparent 70%);
      pointer-events: none;
      animation: bossAttackFlash 0.6s ease-out forwards;
      z-index: 50;
    }

    @keyframes bossAttackFlash {
      0% { opacity: 0.8; }
      100% { opacity: 0; }
    }

    /* Log des derniers coups */
    .hit-log-card {
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 150, 80, 0.25);
      font-size: 13px;
    }

    .hit-log-title {
      font-weight: 700;
      margin-bottom: 6px;
      color: #ffddaa;
    }

    .hit-log-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
      opacity: 0.9;
    }

    .hit-log-row span.hit-name {
      color: #ffe0c2;
    }
    .hit-log-row span.hit-dmg {
      font-weight: 600;
    }    
    .hit-log-row.normal span.hit-dmg {
      color: #ffb36b;
    }
    .hit-log-row.crit span.hit-dmg {
      color: #ffe066;
    }
    .hit-log-row.special span.hit-dmg {
      color: #ff7abf;
    }
    .hit-log-row.boss span.hit-name {
      color: #ff8080;
    }


    
    body {
      margin: 0;
      padding: 0;
      font-family: "Inter", sans-serif;
      background: radial-gradient(circle at bottom, #2a0e00 0%, #050308 70%);
      color: #ffd9b3;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    /* Texture de braises sur tout l'√©cran */
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image:
        radial-gradient(circle at 20% 80%, rgba(255,160,64,0.28) 0, transparent 55%),
        radial-gradient(circle at 70% 90%, rgba(255,90,0,0.35) 0, transparent 55%),
        radial-gradient(circle at 40% 40%, rgba(255,200,120,0.18) 0, transparent 55%),
        radial-gradient(circle at 80% 30%, rgba(255,120,60,0.25) 0, transparent 55%);
      mix-blend-mode: screen;
      opacity: 0.5;
      animation: embersDrift 20s linear infinite alternate;
      z-index: -1;
    }

    @keyframes embersDrift {
      from { transform: translateY(0); }
      to   { transform: translateY(-25px); }
    }

    h1 {
      margin-top: 20px;
      font-size: 32px;
      font-weight: 800;
      color: #ffddaa;
      text-shadow:
        0 0 12px #ff6a00,
        0 0 26px #ff4500,
        0 0 40px rgba(255,69,0,0.7);
      position: relative;
    }

    /* Flamme douce derri√®re le titre */
    h1::after {
      content: "";
      position: absolute;
      inset: -10px -40px;
      background:
        radial-gradient(circle at 50% 120%, rgba(255,140,0,0.75) 0, transparent 60%);
      filter: blur(14px);
      opacity: 0.9;
      z-index: -1;
      animation: flamePulse 2.3s ease-in-out infinite alternate;
    }

    @keyframes flamePulse {
      0% {
        transform: translateY(0) scale(1);
        opacity: 0.6;
      }
      100% {
        transform: translateY(-4px) scale(1.06);
        opacity: 1;
      }
    }

    .container {
      margin-top: 20px;
      width: 90%;
      max-width: 900px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* ---- Status pill ---- */
    .status-pill {
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 16px;
      width: fit-content;
      font-weight: bold;
      color: #fff5e6;
      box-shadow: 0 0 12px rgba(255,120,40,0.7);
      background: linear-gradient(90deg, #803300, #cc5500);
    }

    .status-idle {
      background: linear-gradient(90deg, #4d2a16, #a6471a);
    }
    .status-running {
      background: linear-gradient(90deg, #cc5500, #ff8a2b);
    }
    .status-finished {
      background: linear-gradient(90deg, #992200, #661100);
    }

    /* ---- Cards ---- */
    .card,
    .participants-card,
    .attack-card {
      background: rgba(35, 10, 0, 0.9);
      padding: 20px;
      border-radius: 14px;
      box-shadow:
        0 0 25px rgba(255, 80, 0, 0.25),
        0 0 80px rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255, 150, 70, 0.18);
    }

    .boss-header {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #ffd9b3;
    }

    .boss-name {
      font-size: 26px;
      font-weight: bold;
      color: #ffb36b;
      text-shadow: 0 0 6px #ff6a00;
    }

    /* Image du boss */
    .boss-image-wrapper {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      overflow: hidden;
      background: radial-gradient(circle at 30% 20%, #ffddaa 0, #7a2d00 50%, #2a0e00 100%);
      box-shadow:
        0 0 12px rgba(255, 120, 40, 0.9),
        0 0 26px rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #boss-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
      image-rendering: pixelated;
      transition: opacity 0.3s ease-out;
      opacity: 0;
    }

    /* ---- HP bar ---- */
    .hp-bar-wrapper {
      background: #4d1f00;
      height: 26px;
      border-radius: 12px;
      overflow: hidden;
      margin-top: 15px;
      box-shadow: inset 0 0 8px #120600;
      position: relative;
    }

    .hp-bar-fill {
      background: linear-gradient(90deg, #ff4500, #ff9a00);
      height: 100%;
      transform-origin: left;
      transition: transform 0.5s ease-out;
    }

    .hp-bar-wrapper::after {
      content: "";
      position: absolute;
      inset: -4px;
      pointer-events: none;
      background-image:
        radial-gradient(circle at 10% 50%, rgba(255,255,255,0.7) 0, transparent 45%),
        radial-gradient(circle at 40% 20%, rgba(255,220,150,0.85) 0, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(255,180,80,0.75) 0, transparent 50%);
      mix-blend-mode: screen;
      opacity: 0.0;
      filter: blur(1px);
      animation: sparks 2.8s ease-in-out infinite;
    }

    @keyframes sparks {
      0%, 100% {
        opacity: 0.08;
        transform: translateY(0);
      }
      50% {
        opacity: 0.4;
        transform: translateY(-3px);
      }
    }

    .boss-hit {
      animation: flash 0.25s ease-out;
    }

    @keyframes flash {
      0% { background-color: #ff2200; }
      100% { background-color: #4d1f00; }
    }

    .timer {
      margin-top: 10px;
      font-size: 14px;
      color: #ffcc99;
    }

    /* ---- Participants ---- */
    .participants-card h2 {
      margin-top: 0;
      color: #ffddaa;
      text-shadow: 0 0 6px rgba(255,120,40,0.6);
    }

    .participant-row {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255, 128, 64, 0.3);
    }

    .participant-row:last-child {
      border-bottom: none;
    }

    .participant-name {
      font-size: 16px;
      font-weight: 600;
      color: #ffe0c2;
    }

    .participant-pet {
      font-size: 13px;
      color: #ffb38a;
    }

    .participant-bar-outer {
      background: #7a2d00;
      height: 12px;
      width: 120px;
      border-radius: 6px;
      overflow: hidden;
      position: relative;
    }

    .participant-bar-inner {
      background: linear-gradient(90deg, #ff6a00, #ffb347);
      height: 100%;
      transform-origin: left;
      transition: transform 0.4s ease-out;
    }

    .participant-bar-outer::after {
      content: "";
      position: absolute;
      inset: -2px;
      pointer-events: none;
      background-image:
        radial-gradient(circle at 20% 50%, rgba(255,255,255,0.6) 0, transparent 45%),
        radial-gradient(circle at 70% 40%, rgba(255,210,140,0.6) 0, transparent 50%);
      mix-blend-mode: screen;
      opacity: 0.0;
      filter: blur(0.8px);
      animation: smallSparks 3.4s ease-in-out infinite;
    }

    @keyframes smallSparks {
      0%, 100% {
        opacity: 0.05;
        transform: translateY(0);
      }
      50% {
        opacity: 0.3;
        transform: translateY(-2px);
      }
    }

    .participant-damage {
      text-align: right;
      color: #ffd9b3;
    }

    /* ---- Attack card ---- */
    .attack-card-title {
      margin-top: 0;
      color: #ffddaa;
      text-shadow: 0 0 6px rgba(255,120,40,0.6);
    }

    .attack-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }

    .attack-row input {
      background: rgba(10, 2, 0, 0.9);
      border-radius: 8px;
      border: 1px solid rgba(255, 160, 80, 0.7);
      padding: 6px 10px;
      color: #ffe0c2;
      min-width: 200px;
    }

    .attack-row button {
      border: none;
      border-radius: 999px;
      padding: 8px 18px;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(90deg, #cc5500, #ff9a00);
      color: #2a0500;
      box-shadow: 0 0 14px rgba(255, 140, 60, 0.7);
      transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, opacity 0.2s;
    }

    .attack-row button:disabled {
      opacity: 0.4;
      cursor: default;
      box-shadow: none;
    }

    .attack-row button:active {
      transform: scale(0.97);
      box-shadow: 0 0 6px rgba(255, 120, 40, 0.5);
    }

    .attack-status {
      margin-top: 8px;
      font-size: 14px;
      color: #ffcc99;
    }

    #last-update {
      margin-top: 20px;
      font-size: 14px;
      color: #ffcc99;
      text-shadow: 0 0 8px #ff5500;
    }

    /* üî• INDICATEUR DE TOUR */
    .turn-indicator {
      margin-top: 5px;
      font-size: 15px;
      font-weight: 700;
      color: #ffd9b3;
      text-align: center;
      text-shadow: 0 0 8px rgba(255, 150, 80, 0.6);
    }

    /* üî• SURBRILLANCE JOUEUR EN COURS */
    .participant-row.current-turn {
      background: rgba(255, 160, 60, 0.20);
      border-radius: 10px;
      padding: 10px;
      box-shadow: 0 0 12px rgba(255, 160, 80, 0.35);
    }

    /* üíÄ Pets K.O. (morts) */
    .participant-row.dead {
      opacity: 0.55;
      filter: grayscale(0.9);
    }

    .participant-row.dead .participant-name,
    .participant-row.dead .participant-pet,
    .participant-row.dead .participant-hp-text,
    .participant-row.dead .participant-damage {
      color: #888 !important;
      text-decoration: line-through;
    }

    .participant-hp-text {
      font-size: 12px;
      margin-top: 2px;
      color: #ffddb8;
    }

    .participant-row.dead .participant-hp-bar .participant-bar-inner {
      transform: scaleX(0) !important;
    }

    .participant-ko-label {
      font-weight: 700;
    }

  </style>
</head>

<body>

  <h1>üî• Raid Au Coin Du Feu</h1>

  <div class="container">

    <!-- STATUS -->
    <div class="status-pill status-idle" id="status-pill">
      <span id="status-text">Aucun raid</span>
    </div>

    <!-- TCHAT -->
    <div class="chat-card">
      <h2 class="chat-title">üí¨ Tchat du raid</h2>
      <div id="chat-messages" class="chat-messages"></div>

      <div class="chat-input-row">
        <input id="chat-input" placeholder="√âcris un message..." maxlength="300" />
        <button id="chat-send">Envoyer</button>
      </div>

      <div class="chat-hint">
        Si tu n'as pas rejoint avec <code>/raid_join</code>, ton message sera envoy√© en tant que
        <b>Spectateur</b>.
      </div>
    </div>
    
    <!-- BOSS CARD -->
    <div class="card">
      <div class="boss-header">
        <div class="boss-image-wrapper">
          <img id="boss-image" src="" alt="Boss du raid" />
        </div>
        <div>
          <div id="boss-name" class="boss-name">Aucun raid actif</div>
          <div id="boss-stars" style="color: #ffdd55; font-size: 18px;"></div>
        </div>
      </div>

      <div class="hp-bar-wrapper" id="hp-wrapper">
        <div class="hp-bar-fill" id="hp-fill"></div>
      </div>

      <div id="hp-text" style="margin-top: 8px; font-size: 16px;">
        0 / 0
      </div>

      <div id="difficulty-label" style="margin-top: 10px; font-weight: bold;"></div>
      <div class="timer" id="timer-status"></div>
      <div class="timer" id="timer-range"></div>
    </div>

    <!-- ATTACK CARD -->
    <div class="attack-card">
      <h2 class="attack-card-title">‚öîÔ∏è Attaque le boss</h2>
      <p style="margin:0;font-size:14px;color:#ffcc99;">
        Renseigne ton <b>Pseudo Discord: EX (Pseudo#0000/Pseudo0000)</b> (le m√™me compte qui a fait <code>/raid_join</code>), puis clique sur <b>Attaquer</b>.
      </p>
      <div class="attack-row">
        <input id="user-name-input" placeholder="Ton pseudo Discord (ex: Pseudo#0000)" />
        <button id="attack-button" disabled>‚öîÔ∏è Attaquer</button>
        <button id="open-items">üéí Objets</button>
      </div>
      <div id="attack-status" class="attack-status"></div>
    </div>

    <div id="items-panel" class="items-panel" style="display:none;">
        <h3>üéí Objets disponibles</h3>
        <div id="items-list" class="items-list"></div>
        <button id="close-items" class="close-items-btn">Fermer</button>
    </div>

    <!-- PARTICIPANTS -->
    <div class="participants-card">
      <h2>üë• Participants</h2>

      <!-- üî• INDICATEUR DE TOUR -->
      <div id="turn-indicator" class="turn-indicator">Tour de : ‚Äî</div>

      <div id="participants-count">0 joueurs</div>

      <div id="participants-list" style="margin-top: 15px;"></div>
      <div id="participants-empty" style="text-align:center; padding: 10px; color:#aaa; display:none;">
        Aucun joueur pour le moment‚Ä¶
      </div>
       <!-- üî• Log des derniers coups -->
      <div class="hit-log-card">
        <div class="hit-log-title">Derniers coups</div>
        <div id="hit-log-list"></div>
      </div>
    </div>

  <div id="last-update"></div>

  <!-- SCRIPT -->
  <script>
    // ‚öôÔ∏è URL de ton API Render
    const API_BASE = "https://raid-api-la5d.onrender.com";
    const STATE_ENDPOINT = API_BASE + "/raid/state";
    const ATTACK_ENDPOINT = API_BASE + "/raid/attack";

    let prevState = null;
    let currentUserId = null;
    let hitLog = [];
    let chatMessagesCache = [];



    // Base de d√©g√¢ts pour un coup "normal" (√† adapter si tu changes le raid)
    const BASE_DAMAGE = 150;

    function classifyHit(dmg) {
      if (dmg >= BASE_DAMAGE * 3) return "ultimate"; // tr√®s gros coup
      if (dmg >= BASE_DAMAGE * 2) return "crit";     // coup critique
      return "normal";                               // coup normal
    }



    function renderChat(messages) {
  const box = document.getElementById("chat-messages");
  if (!box) return;
  box.innerHTML = "";

  messages.forEach(msg => {
    const row = document.createElement("div");
    row.className = "chat-message";

    const nameSpan = document.createElement("span");

    if (msg.is_spectator) {
      const spec = document.createElement("span");
      spec.className = "chat-spectator-tag";
      spec.textContent = "[Spectateur]";
      row.appendChild(spec);
    }

    nameSpan.className = "chat-name";
    nameSpan.textContent = msg.name + " : ";
    row.appendChild(nameSpan);

    const textSpan = document.createElement("span");
    textSpan.className = "chat-text";
    textSpan.textContent = msg.content;
    row.appendChild(textSpan);

    box.appendChild(row);
  });

  // scroll en bas
  box.scrollTop = box.scrollHeight;
}

async function fetchChat() {
  try {
    const res = await fetch(API_BASE + "/raid/chat?t=" + Date.now());
    if (!res.ok) return;
    const data = await res.json();
    chatMessagesCache = data;
    renderChat(chatMessagesCache);
  } catch (e) {
    console.error("Erreur chat:", e);
  }
}

async function sendChatMessage() {
  const input = document.getElementById("chat-input");
  const txt = (input.value || "").trim();
  if (!txt) return;

  // On r√©cup√®re le nom d√©j√† saisi pour l'attaque (pseudo)
  const nameStored = localStorage.getItem("raid_user_name") || "";
  const pseudo = nameStored || "Inconnu";

  try {
    const res = await fetch(API_BASE + "/raid/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        user_id: currentUserId,   // peut √™tre null ‚Üí Spectateur auto
        name: pseudo,
        content: txt
      })
    });
    if (!res.ok) {
      console.warn("Chat POST failed");
      return;
    }
    input.value = "";
    // on rafra√Æchit le tchat juste apr√®s
    fetchChat();
  } catch (e) {
    console.error("Erreur envoi chat:", e);
  }
}

    
    
    function updateHitLogView() {
      const list = document.getElementById("hit-log-list");
      if (!list) return;
      list.innerHTML = "";

      hitLog.forEach(entry => {
        const row = document.createElement("div");
        row.className = "hit-log-row " + (entry.kind || "normal");

        if (entry.type === "boss") {
          row.classList.add("boss");
        }

        const nameSpan = document.createElement("span");
        nameSpan.className = "hit-name";
        nameSpan.textContent = entry.type === "boss"
          ? entry.name || "Boss"
          : (entry.name || "Joueur");

        const dmgSpan = document.createElement("span");
        dmgSpan.className = "hit-dmg";
        dmgSpan.textContent = `-${formatNumber(entry.damage)} dmg`;

        row.appendChild(nameSpan);
        row.appendChild(dmgSpan);
        list.appendChild(row);
      });
    }

    function triggerBossAttackFlash() {
      const overlay = document.createElement("div");
      overlay.className = "boss-attack-overlay";
      document.body.appendChild(overlay);
      setTimeout(() => overlay.remove(), 600);
    }

    // R√©cup√®re l'ID stock√©
    function loadUserId() {
      try {
        const storedName = localStorage.getItem("raid_user_name");
        const storedId = localStorage.getItem("raid_user_id");

        const input = document.getElementById("user-name-input");
        if (storedName && input) {
          input.value = storedName;
        }
        if (storedId) {
          currentUserId = storedId;
        }
      } catch (e) {}

      updateAttackButtonState();
    }

    async function saveUserName() {
      const input = document.getElementById("user-name-input");
      const val = (input.value || "").trim();

      if (!val) {
        currentUserId = null;
        localStorage.removeItem("raid_user_name");
        localStorage.removeItem("raid_user_id");
        updateAttackButtonState();
        return;
      }

      // On garde le pseudo
      localStorage.setItem("raid_user_name", val);

      // On va chercher l'ID associ√©
      const resolved = await resolveUserIdFromName(val);

      if (!resolved) {
        currentUserId = null;
        localStorage.removeItem("raid_user_id");
        document.getElementById("attack-status").textContent =
          "‚ùå Joueur introuvable dans le raid. Assure-toi d'avoir fait /raid_join.";
      } else {
        currentUserId = resolved;
        localStorage.setItem("raid_user_id", resolved);
        document.getElementById("attack-status").textContent =
          "‚úÖ Joueur reconnu : " + val;
      }

      updateAttackButtonState();
    }

    function updateAttackButtonState(statusData) {
      const btn = document.getElementById("attack-button");
      const status = document.getElementById("attack-status");

      if (!currentUserId) {
        btn.disabled = true;
        status.textContent = "Renseigne ton ID Discord pour pouvoir attaquer.";
        return;
      }
      if (!statusData || statusData.status !== "running") {
        btn.disabled = true;
        status.textContent = "Aucun raid actif.";
        return;
      }
      // üîé trouver mon enregistrement de participant
      const me = (statusData.participants || []).find(
        p => String(p.user_id) === String(currentUserId)
      );
      if (!me) {
        btn.disabled = true;
        status.textContent = "Tu n'es pas inscrit au raid (/raid_join).";
        return;
      }
      // üîí si mon pet est K.O. -> plus d'attaque
      if (me.hp_current !== undefined && me.hp_max !== undefined) {
        if (me.hp_max > 0 && me.hp_current <= 0) {
          btn.disabled = true;
          status.textContent = "Ton familier est K.O., tu ne peux plus attaquer dans ce raid.";
          return;
        }
      }

      // üîÅ contr√¥le du tour
      if (statusData.current_turn && currentUserId) {
        if (String(statusData.current_turn) !== String(currentUserId)) {
          btn.disabled = true;
          status.textContent = "Ce n'est pas ton tour. Patiente‚Ä¶";
          return;
        }
      }

      btn.disabled = false;
      status.textContent = "C'est ton tour ! Clique sur Attaquer.";
    }

    function formatNumber(n) {
      return (n || 0).toLocaleString("fr-FR");
    }

    function starsLabel(stars) {
      stars = Number(stars) || 0;
      const s = "‚≠ê".repeat(Math.max(1, Math.min(7, stars)));
      switch (stars) {
        case 2: return s + " (Facile)";
        case 3: return s + " (Normal)";
        case 4: return s + " (Difficile)";
        case 5: return s + " (Expert)";
        case 6: return s + " (L√©gendaire)";
        case 7: return s + " (Mythique)";
        default: return s;
      }
    }

    function formatTimer(startTs, endTs, status) {
      const now = Date.now() / 1000;
      if (!startTs || !endTs) return "";
      const remaining = endTs - now;
      if (status === "finished" || remaining <= 0) return "‚è± Termin√©";
      const total = endTs - startTs;
      return `‚è± ${Math.round((now-startTs)/60)} min / ${Math.round(total/60)} min`;
    }

    function updateBossView(data) {
      const bossNameEl = document.getElementById("boss-name");
      const bossStarsEl = document.getElementById("boss-stars");
      const hpTextEl = document.getElementById("hp-text");
      const hpFillEl = document.getElementById("hp-fill");
      const hpWrapperEl = document.getElementById("hp-wrapper");
      const timerStatusEl = document.getElementById("timer-status");
      const timerRangeEl = document.getElementById("timer-range");
      const diffLabelEl = document.getElementById("difficulty-label");
      const bossImgEl = document.getElementById("boss-image");
      

      if (!data || data.status !== "running") {
        bossNameEl.textContent = "Aucun raid actif";
        bossStarsEl.textContent = "";
        hpTextEl.textContent = "0 / 0";
        hpFillEl.style.transform = "scaleX(0)";
        diffLabelEl.textContent = "";
        timerStatusEl.textContent = "Le raid est termin√© ou inactif.";
        timerRangeEl.textContent = "";
        if (bossImgEl) {
          bossImgEl.src = "";
          bossImgEl.style.opacity = "0.0";
        }
        return;
      }

      const bossName = data.boss || "Boss";
      const hpCur = Number(data.hp_current) || 0;
      const hpMax = Math.max(1, Number(data.hp_max) || 1);
      const stars = Number(data.stars) || 0;

      bossNameEl.textContent = bossName;
      bossStarsEl.textContent = "‚≠ê".repeat(stars);

      // Image du boss: assets/<ID>.png
      if (bossImgEl && data.boss) {
        const imgPath = `assets/${data.boss}.png`;
        bossImgEl.style.opacity = "0.0";
        bossImgEl.src = imgPath;
        bossImgEl.onload = () => {
          bossImgEl.style.opacity = "1";
        };
        bossImgEl.onerror = () => {
          bossImgEl.style.opacity = "0.0";
        };
      }

      hpTextEl.textContent = `${formatNumber(hpCur)} / ${formatNumber(hpMax)}`;
      hpFillEl.style.transform = `scaleX(${Math.max(0, Math.min(1, hpCur/hpMax))})`;

      diffLabelEl.textContent = starsLabel(stars);

      timerStatusEl.textContent = formatTimer(data.start, data.end, data.status);
      if (data.start && data.end) {
        timerRangeEl.textContent =
          `Du ${new Date(data.start*1000).toLocaleString("fr-FR")} au ${new Date(data.end*1000).toLocaleString("fr-FR")}`;
      } else {
        timerRangeEl.textContent = "";
      }

            // Animation si le boss perd des HP
      if (prevState && prevState.hp_current > hpCur) {
        const diff = prevState.hp_current - hpCur;

        // 1) flash sur la barre de PV
        hpWrapperEl.classList.remove("boss-hit");
        void hpWrapperEl.offsetWidth;
        hpWrapperEl.classList.add("boss-hit");

        // 2) shake sur l'image du boss
        const bossImgWrapper = document.querySelector(".boss-image-wrapper");
        if (bossImgWrapper) {
          bossImgWrapper.classList.remove("hit");
          void bossImgWrapper.offsetWidth;
          bossImgWrapper.classList.add("hit");
        }

        // 3) popup de d√©g√¢ts color√©e
        if (diff > 0) {
          const kind = classifyHit(diff); // normal / crit / ultimate
          const popup = document.createElement("div");
          popup.className = "damage-popup " + kind;
          popup.textContent = "-" + formatNumber(diff);

          hpWrapperEl.appendChild(popup);

          setTimeout(() => popup.remove(), 900);

          // 4) ajout au log des coups (coup du joueur)
          let attackerName = null;
          const attackerId = prevState.current_turn;
          if (attackerId && Array.isArray(data.participants)) {
            const p = data.participants.find(pp => String(pp.user_id) === String(attackerId));
            if (p) attackerName = p.name;
          }

          hitLog.unshift({
            type: "player",
            name: attackerName || "Joueur inconnu",
            damage: diff,
            ts: Date.now(),
            kind: kind,
          });
          hitLog = hitLog.slice(0, 8); // on garde les 8 derniers
          updateHitLogView();
        }
      }

      // D√©tection approximative d'une "attaque du boss" :
      // si le tour change, mais que les PV du boss n'ont pas boug√©.
      if (
        prevState &&
        prevState.current_turn &&
        data.current_turn &&
        prevState.current_turn !== data.current_turn &&
        prevState.hp_current === hpCur
      ) {
        // flash rouge plein √©cran
        triggerBossAttackFlash();

        // log de l'attaque du boss
        hitLog.unshift({
          type: "boss",
          name: "Boss",
          damage: 0,
          ts: Date.now(),
          kind: "boss",
        });
        hitLog = hitLog.slice(0, 8);
        updateHitLogView();
      }
    }

    function updateParticipantsView(data) {
      const listEl = document.getElementById("participants-list");
      const emptyEl = document.getElementById("participants-empty");
      const countEl = document.getElementById("participants-count");
      const turnIndEl = document.getElementById("turn-indicator");

      const participants = Array.isArray(data.participants) ? data.participants : [];
      const currentTurn = data.current_turn || null;

      if (participants.length === 0) {
        listEl.innerHTML = "";
        emptyEl.style.display = "block";
        countEl.textContent = "0 joueurs";
        if (turnIndEl) turnIndEl.textContent = "Tour de : ‚Äî";
        return;
      }

      emptyEl.style.display = "none";
      countEl.textContent = `${participants.length} joueurs`;

      // Joueur dont c'est le tour
      let currentName = null;
      if (currentTurn) {
        const cur = participants.find(p => String(p.user_id) === String(currentTurn));
        if (cur) currentName = cur.name || cur.user_id;
      }
      if (turnIndEl) {
        turnIndEl.textContent = currentName
          ? `Tour de : ${currentName}`
          : "Tour de : ‚Äî";
      }

      listEl.innerHTML = "";
      participants.sort((a,b)=>b.damage - a.damage);

      let max = participants[0]?.damage || 1;

            for (let p of participants) {
                const row = document.createElement("div");
                row.classList.add("participant-row");

                // ‚úÖ on r√©cup√®re les HP si l'API les envoie (sinon 0)
                const hpCur = p.hp_current || 0;
                const hpMax = p.hp_max || 0;
                const isDead = (hpMax > 0 && hpCur <= 0) || p.alive === false;

                if (isDead) {
                  row.classList.add("dead");
                }

                // Nom + cr√¢ne si mort
                const nameHtml = isDead
                  ? `<div class="participant-name dead-name">üíÄ ${p.name}</div>`
                  : `<div class="participant-name">${p.name}</div>`;

                // Pet + HP / K.O.
                let petHtml = `<div class="participant-pet">${p.pet}</div>`;
                if (hpMax > 0) {
                  if (isDead) {
                    petHtml += `<div class="participant-hp ko">K.O.</div>`;
                  } else {
                    petHtml += `<div class="participant-hp">${formatNumber(hpCur)} / ${formatNumber(hpMax)} HP</div>`;
                  }
                }

                const col1 = document.createElement("div");
                col1.innerHTML = nameHtml + petHtml;

                const col2 = document.createElement("div");
                col2.className = "participant-damage";
                const barOuter = document.createElement("div");
                barOuter.className = "participant-bar-outer";
                const barInner = document.createElement("div");
                barInner.className = "participant-bar-inner";
                barInner.style.transform = `scaleX(${p.damage/max})`;

                barOuter.appendChild(barInner);
                col2.innerHTML = `${formatNumber(p.damage)} dmg`;
                col2.appendChild(barOuter);

                row.appendChild(col1);
                row.appendChild(col2);
                listEl.appendChild(row);
              }
            }

    function updateStatusPill(data) {
      const pill = document.getElementById("status-pill");
      const text = document.getElementById("status-text");

      pill.classList.remove("status-idle","status-running","status-finished");

      if (!data) {
        pill.classList.add("status-idle");
        text.textContent = "Aucun raid";
      } else if (data.status === "running") {
        pill.classList.add("status-running");
        text.textContent = "Raid en cours";
      } else if (data.status === "finished") {
        pill.classList.add("status-finished");
        text.textContent = "Raid termin√©";
      } else {
        pill.classList.add("status-idle");
        text.textContent = "Aucun raid";
      }
    }

    function setLastUpdate() {
      document.getElementById("last-update").textContent =
        "Derni√®re mise √† jour : " + new Date().toLocaleTimeString("fr-FR");
    }

    async function fetchRaidState() {
      let data = null;
      const previous = prevState; // on garde l'ancien √©tat pour comparer

      try {
        const res = await fetch(STATE_ENDPOINT + "?t=" + Date.now());
        data = await res.json();

        // üî• D√©tection des attaques du boss : on regarde les HP des pets
        if (previous && Array.isArray(previous.participants) && Array.isArray(data.participants)) {
          const oldById = {};
          for (const p of previous.participants) {
            oldById[String(p.user_id)] = p;
          }

          let bossDidSomething = false;

          for (const p of data.participants) {
            const old = oldById[String(p.user_id)];
            if (!old) continue;

            const oldHp = old.hp_current || 0;
            const newHp = p.hp_current || 0;

            if (oldHp > newHp) {
              const diff = oldHp - newHp;
              const kind = classifyHit(diff); // normal / crit / ultimate

              hitLog.unshift({
                type: "boss",
                name: `Boss ‚Üí ${p.name || "???"} `,
                damage: diff,
                ts: Date.now(),
                kind: kind,
              });
              bossDidSomething = true;
            }
          }

          if (bossDidSomething) {
            hitLog = hitLog.slice(0, 8);
            updateHitLogView();
            triggerBossAttackFlash(); // petit flash rouge quand le boss frappe
          }
        }

        // üîÅ mise √† jour classique de l'affichage
        updateBossView(data);
        updateParticipantsView(data);
        updateStatusPill(data);
        prevState = data;

        // üî• D√©tection d'une utilisation d'objet
        if (prevState && Array.isArray(prevState.participants) && Array.isArray(data.participants)) {
          const oldById = {};
          for (const p of prevState.participants) {
            oldById[String(p.user_id)] = p;
          }

          let itemUsed = false;

          for (const p of data.participants) {
            const old = oldById[String(p.user_id)];
            if (!old) continue;

            const oldItem = old.last_item_used || null;
            const newItem = p.last_item_used || null;

            // nouvel objet utilis√© (ou objet diff√©rent)
            if (newItem && newItem !== oldItem) {
              hitLog.unshift({
                type: "item",
                name: p.name || "Joueur",
                damage: p.last_item_value || 0,
                ts: Date.now(),
                kind: "special",
                item_id: newItem,
              });
              itemUsed = true;
            }
          }

          if (itemUsed) {
            hitLog = hitLog.slice(0, 8);
            updateHitLogView();
          }
        }

        // Adaptation dynamique du refresh
        if (data && data.status) {
          setDynamicRefresh(data.status);
        }
      } catch (e) {
        console.error("Erreur API:", e);
      }
      setLastUpdate();
      updateAttackButtonState(data || { status: "idle" });
    }


    async function sendAttack() {
      const status = document.getElementById("attack-status");
      const btn = document.getElementById("attack-button");

      if (!currentUserId) {
        status.textContent = "Merci de renseigner ton ID Discord.";
        return;
      } 

      // üîí on bloque le bouton d√®s le clic
      btn.disabled = true;
      status.textContent = "Envoi de ton attaque...";

      try {
        const res = await fetch(ATTACK_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ user_id: currentUserId })
        });

        if (!res.ok) {
          const err = await res.json().catch(()=>({}));
          status.textContent = err.detail || "Erreur lors de l'attaque.";
          // on laisse updateAttackButtonState d√©cider de le r√©activer ou non au prochain tick
          return;
        }

        status.textContent = "‚úÖ Attaque envoy√©e ! (si tu es inscrit au raid)";
        // le bouton sera r√©activ√© ou non par updateAttackButtonState
      } catch (e) {
        console.error(e);
        status.textContent = "Erreur r√©seau lors de l'attaque.";
        // en cas de vraie erreur r√©seau, tu peux √©ventuellement r√©activer :
        // btn.disabled = false;
      }
    }


    async function loadItems() {
      if (!currentUserId) return [];

      const res = await fetch(API_BASE + "/raid/items?user_id=" + currentUserId);
      return await res.json();
    }



    async function openItemsPanel() {
      const panel = document.getElementById("items-panel");
      const list = document.getElementById("items-list");

      list.innerHTML = "Chargement...";

      panel.style.display = "block";

      const items = await loadItems();

      if (items.length === 0) {
        list.innerHTML = "<i>Aucun objet disponible</i>";
        return;
      }

      list.innerHTML = "";

      items.forEach(item => {
        const btn = document.createElement("button");
        btn.textContent = `${item.name} (${item.effect})`;
        btn.addEventListener("click", () => useItem(item.id));
        list.appendChild(btn);
      });
    }


    function closeItemsPanel() {
      document.getElementById("items-panel").style.display = "none";
    }


    async function useItem(itemId) {
      if (!currentUserId) return;

      const res = await fetch(API_BASE + "/raid/use_item", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({
          user_id: currentUserId,
          item_id: itemId
        })
      });

      if (res.ok) {
        document.getElementById("attack-status").textContent =
          "üéí Objet utilis√© !";
        closeItemsPanel();
      } else {
        const err = await res.json().catch(()=>({detail:"Erreur"}));
        document.getElementById("attack-status").textContent =
          "‚ùå " + err.detail;
      }
    }


    
    async function resolveUserIdFromName(name) {
      const url = API_BASE + "/raid/resolve_user?name=" + encodeURIComponent(name);
      try {
        const res = await fetch(url);
        const data = await res.json();
        if (data.user_id) return data.user_id;
      } catch(e) {}
      return null;
    }

    // --- Init variables ---
    let refreshInterval = null;


    // Events
    document.getElementById("open-items").addEventListener("click", openItemsPanel);
    document.getElementById("close-items").addEventListener("click", closeItemsPanel);
    document.getElementById("user-name-input").addEventListener("input", saveUserName);   // instantan√©
    document.getElementById("user-name-input").addEventListener("change", saveUserName);  // fallback
    document.getElementById("attack-button").addEventListener("click", sendAttack);
    document.getElementById("chat-send").addEventListener("click", sendChatMessage);
    document.getElementById("chat-input").addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        sendChatMessage();
      }
    });

    
    // --- Dynamic refresh du raid ---
    function setDynamicRefresh(status) {
      if (refreshInterval) clearInterval(refreshInterval);

      if (status === "running") {
        // Pendant un raid ‚Üí refresh rapide
        refreshInterval = setInterval(fetchRaidState, 1000);
      } else {
        // Raid termin√© ou inactif ‚Üí refresh plus lent
        refreshInterval = setInterval(fetchRaidState, 5000);
      }
    }

    // --- Init au chargement de la page ---
    loadUserId();

    // 1er fetch raid + le raid lui-m√™me adaptera le refresh (via setDynamicRefresh dans fetchRaidState)
    fetchRaidState();

    // 1er fetch tchat pour afficher l'historique directement
    fetchChat();
    setInterval(fetchChat, 3000); // raffra√Æchit ensuite toutes les 3s

    // Si tu veux un mode par d√©faut avant la 1√®re r√©ponse API :
    setDynamicRefresh("idle");
  </script>

</body>
</html>























